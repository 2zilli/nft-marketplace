// // Unit test module for NFT-related functionalities.
// @test module;

// import nft_marketplace.*;

// // Test creating a collection
// function test_create_collection() {
//     // Create a user
//     rell.test.tx()
//         .op(create_user("Grace", "gracePassword"))
//         .run();

//     // Create a collection
//     rell.test.tx()
//         .op(create_collection("Grace", "gracePassword", "Grace's NFT Collection"))
//         .run();

//     // Check if the collection was created
//     val created_collection = nft_collection @ { .owner == "Grace" } ( .collection_id, .description, .owner ); // Only 1 hit or fail
//     assert_equals(created_collection.description, "Grace's NFT Collection");
// }

// // Test minting an NFT without a collection
// function test_mint_nft_without_collection() {
//     // Create a user to own the NFT
//     rell.test.tx()
//         .op(create_user("David", "davidPassword"))
//         .run();

//     // Mint an NFT
//     rell.test.tx()
//         .op(mint_nft("David", "davidPassword", "A unique NFT", -1))
//         .run();

//     // Check if the NFT was created
//     val unique_nft = nft @ { .owner == "David" } ( .nft_id, .description, .owner, .collection_id ); // Only 1 hit or fail
//     assert_equals(unique_nft.description, "A unique NFT");
//     assert_equals(unique_nft.collection_id, -1);
// }

// // Test creating a collection and minting an NFT in it
// function test_create_collection_and_mint_nft() {
//     // Create a user
//     rell.test.tx()
//         .op(create_user("Henry", "henryPassword"))
//         .run();

//     // Create a collection
//     rell.test.tx()
//         .op(create_collection("Henry", "henryPassword", "Henry's Art Collection"))
//         .run();

//     // Get the collection_id of the created collection
//     val collection_id = nft_collection @ { .owner == "Henry" } ( .collection_id );

//     // Mint an NFT in the collection
//     rell.test.tx()
//         .op(mint_nft("Henry", "henryPassword", "Henry's first NFT", collection_id))
//         .run();

//     // Check if the NFT was created in the collection
//     val collection_nft = nft @ { .owner == "Henry" } ( .nft_id, .description, .owner, .collection_id ); // Only 1 hit or fail
//     assert_equals(collection_nft.description, "Henry's first NFT");
//     assert_equals(collection_nft.collection_id, collection_id);
// }

// // Test minting an NFT with a collection
// function test_mint_nft_with_collection() {
//     // Create a user and a collection
//     rell.test.tx()
//         .op(create_user("Eve", "evePassword"))
//         .op(create_collection("Eve", "evePassword", "Eve's Art Collection"))
//         .run();

//     // Get the collection_id of the created collection
//     val collection_id = nft_collection @ { .owner == "Eve" } ( .collection_id );

//     // Mint an NFT in the collection
//     rell.test.tx()
//         .op(mint_nft("Eve", "evePassword", "An NFT in a collection", collection_id))
//         .run();

//     // Check if the NFT was created in the collection
//     val collection_nft = nft @ { .owner == "Eve" } ( .nft_id, .description, .owner, .collection_id ); // Only 1 hit or fail
//     assert_equals(collection_nft.description, "An NFT in a collection");
//     assert_equals(collection_nft.collection_id, collection_id);
// }

// // Test minting an NFT with an invalid collection ID
// function test_mint_nft_with_invalid_collection() {
//     // Create a user
//     rell.test.tx()
//         .op(create_user("Frank", "frankPassword"))
//         .run();

//     // Attempt to mint an NFT with an invalid collection ID
//     assert_fails(rell.test.tx()
//         .op(mint_nft("Frank", "frankPassword", "NFT with bad collection ID", 999))
//         .run(*));
// }
